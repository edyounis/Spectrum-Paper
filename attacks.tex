\section{Speculative Attack Replication}

To our knowledge, speculative attacks have not been implemented on BOOM yet. Thus,
this project was focused on demonstrating that these attacks could occur by showing
simple proof of concept code for the attacks. Initially, the goal was to implement
Spectre-v1, otherwise known as Bounds Check Bypass, and the Return Stack Buffer attack.
However, due to implementation caveats, we shifted from demonstrating the Return Stack 
Buffer attack to showing Spectre-v2, otherwise known as the Branch Target Injection 
attack.

\subsection{Implementation Details}

This project utilizes the Berkeley Out-of-Order Machine (BOOM), a synthesizable and 
parameterizable open source RV64G RISC-V core written in the Chisel hardware construction language. 
Since the core is open source, it provides the team insight into the inner working of the core
in order to replicate the attack quickly. However, despite this there were a couple of issues 
relating to both the core and RISC-V that needed to be worked around in order to 
replicate the attacks since the core is transitioning to a more stable version.

\subsubsection{Handmade clflush}

One feature of normal x86 and ARM processors that is not available in RV64G is the presence of
a {\tt clflush}, cache line flush, instruction. This instruction is extremely important for 
cache side channel attacks since it enables a timing leak depending on if the cache line is
present in the cache hierarchy or not. Therefore, a workaround was made to implement a 
L1 cache flush function. This function takes in an address and size in bytes, and flushes
all sets starting from that address until the size. This is done by having an extra array, 
a multiple of the L1 cache size, that is indexed into to evict a particular line. Since we are
not able to evict a particular line ({\tt clflush} is able to selectively remove a line within a set),
this function instead evicts the entire set to ensure that the line referenced is evicted. Evicting
the entire set is done by hitting the set {\tt N * L1Way} amount, where {\tt N} is the large enough number to 
account for the random cache replacement, so that all lines are evicted.
\subsubsection{BOOM Branch Predictor Unit}

The BOOM Branch Predictor Unit (BPU), is split into a single-cycle "next-line predictor" (NLP) and a
slower but more complicated "backing predictor" (BP). The NLP contains the Branch Target Buffer (BTB) 
where more recent branches are cached alongside their target, a tag of the PC, and more. Additionally,
the NLP contains the Return Stack Buffer (RSB) which holds the return pointer for a ret instruction. The BP
consists of a large predictor such as TAGE or GShare which makes a more accurate prediction based on
a larger view of the branch history. From the time that we were working on this project, the BOOM 
processor had multiple issues with the TAGE BP, RSB, and other small BPU bugs. For simplicity and 
to avoid bug-fixing the core instead of working on the attacks, we switched to using a GShare BP
having a global history of 23 bits and history table containing 4096 counters. This was significantly
less buggy while also providing a simpler approach to training the BPU. Additionally, when trying to
implement the RSB attack, the RSB was disabled in the code resulting in all ret's to speculate to
the next PC instead of the target PC. Re-enabling the RSB lead to multiple other BPU bugs, so we
ending up keeping the RSB disabled and instead implemented another attack which did not use the RSB.

\subsubsection{BOOM Memory System}

BOOM's memory system utilizes the RocketChip L1 Data Cache and connects to the rest of the RocketChip
infrastructure. However, within the RocketChip tile there is no implementation of a L2 cache, instead
there is a notion of a infinite memory after the L1 cache. This unique memory hierarchy still functions
properly, however when implementing the different attacks, it was noticed that the speculation window
was not large enough due to memory latencies not being sufficiently large. This is because the
dependent load causing speculation would resolve quickly, resulting in other speculative loads to not
finish. Therefore, a workaround was made to use BOOM's floating point unit to expand the speculation 
window through using {\tt fdiv} instructions. When used on the dependency, this would allow the speculation
to run for a longer time.


\subsection{Bounds Check Bypass Attack}

This attack exploits the functionality of conditional branches to leak a secret byte 
when and attacker resides in the same address space. The attack works by a 
malicious entity training a conditional branch within victim code to predict the branch
to be taken in a certain direction, then during the attack round, the malicious entity
gives a value to the victim that is used to retrieve the index during the speculative
execution. This particular attack variant uses a cache side channel attack to leak the
information by having the secret value index into another array that the attacker has
access to after the secret was accessed. The psuedocode in \ref{code:spectre-v1-pseudo}
demonstrates the basic principle of the attack using a C-like syntax.

\begin{lstlisting}[style=column-code, caption=Psuedocode of Bounds Check Bypass Attack]
char* secret[] = "SECRET_VALUE"
char  attackArray[256 * CACHE_BLOCK_SZ]

void victim(idx){
  if (idx < secret.size()){
    attackArray[secret[idx] * CACHE_BLOCK_SZ]
  }
}

int main(void){
  
  // Training
  while (TRAINING_ROUNDS){
    victim(idx)
  }

  // Attack. Read secret value
  victim(outOfBoundsIdx)

  // Probe array to check for hit
  for (i -> 0 until 256){
    t0 = time()
    attackArray[i * CACHE_BLOCK_SZ]
    t1 = time()
  }
}
\end{lstlisting}\label{code:spectre-v1-pseudo}

The BOOM implementation of this attack echos the psuedocode closely. It consists of 3
different parts. First, a tally buffer is cleared before reading a secret byte. Next the
array to be probed is evicted from the cache, and the attack trains the BPU to enter the 
bounds protected area. Note that in this section, there is an extra loop that puts the 
branch history in a consistent state since the branch history is hashed on update. Finally,
the attacker code reads out the probing array through using the {\tt rdcycle} instruction and 
checking if the result is under a hand tuned cache threshold. The full code is available at
\ref{ref:Appendix ?}.

\subsection{Branch Target Injection}

This attack exploits the functionality of the Branch Target Buffer in predicting the outcome
of jump and link instructions that use the BTB to predict where it will branch. Specifically, 
the attack works by a malicious entity training a jump and link instruction to default point to 
the victim code. Then during the attack run, the jump is supposed to go to a wanted function,
but instead due to the BTB pointing to the original victim code, it speculatively jumps to the
victim code and executes it. This particular attack variant also leaks information through the
cache side channel mentioned in \ref{ref:Bounds Check Bypass Attack}. The psuedocode in 
\ref{code:spectre-v2-psuedo} demonstrates the basic principle of the attack using a C-like syntax.

\begin{lstlisting}[style=column-code, caption=Psuedocode of Bounds Check Bypass Attack]
char* secret[] = "SECRET_VALUE"
char  attackArray[256 * CACHE_BLOCK_SZ]

void otherFunction(void){
  // Other functionality    
}

void victim(idx){ attackArray[secret[idx] * CACHE_BLOCK_SZ] }

int main(void){
  
  // Training
  while (TRAINING_ROUNDS){
    jump(victim)
  }

  // Attack. Read secret value
  argument = attackIdx
  jump(otherFunction)

  // Probe array to check for hit
  for (i -> 0 until 256){
    t0 = time()
    attackArray[i * CACHE_BLOCK_SZ]
    t1 = time()
  }
}
\end{lstlisting}\label{code:spectre-v2-pseudo}

The BOOM implementation of this attack is very similar to the implementation given for
the bounds check bypass attack listed in \ref{ref:Bounds Check Bypass}. One of the main differences
for this attack is that the attacker has to change both the address of the function and the
index of the array access in the victim for the training. Additionally, the {\tt fdiv} manipulation is 
done in the main function versus the victim code.
